import { writeFile } from 'fs/promises';
import { format } from 'prettier';
import { DatabaseManager } from './database-manager';
import type { TableInfo, ColumnInfo } from './types';

export class TypeGenerator {
  private db: DatabaseManager;

  constructor(db: DatabaseManager) {
    this.db = db;
  }

  /**
   * Generate TypeScript types from database schema
   */
  async generateTypes(outputPath: string): Promise<void> {
    const tables = await this.db.getTables();
    let typescript = this.generateHeader();

    // Database interface
    typescript += 'export interface Database {\n';
    typescript += '  public: {\n';
    typescript += '    Tables: {\n';

    for (const table of tables) {
      if (table.tableType !== 'BASE TABLE') continue;

      const columns = await this.db.getColumns(table.tableName);
      typescript += this.generateTableType(table.tableName, columns);
    }

    typescript += '    };\n';
    typescript += '  };\n';
    typescript += '}\n';

    // Format with Prettier
    const formatted = await format(typescript, {
      parser: 'typescript',
      singleQuote: true,
      trailingComma: 'es5',
      printWidth: 100,
    });

    // Write to file
    await writeFile(outputPath, formatted, 'utf-8');
  }

  /**
   * Generate header comment
   */
  private generateHeader(): string {
    return `/**
 * Database type definitions
 * Auto-generated from PostgreSQL schema
 * DO NOT EDIT MANUALLY
 */

`;
  }

  /**
   * Generate type definition for a single table
   */
  private generateTableType(tableName: string, columns: ColumnInfo[]): string {
    let ts = `      ${tableName}: {\n`;

    // Row type (exact database structure)
    ts += '        Row: {\n';
    for (const col of columns) {
      const tsType = this.postgresTypeToTS(col.dataType);
      const nullable = col.isNullable ? ' | null' : '';
      ts += `          ${col.columnName}: ${tsType}${nullable};\n`;
    }
    ts += '        };\n';

    // Insert type (omit auto-generated fields)
    ts += '        Insert: {\n';
    for (const col of columns) {
      const tsType = this.postgresTypeToTS(col.dataType);
      const optional = this.isAutoGenerated(col) || col.isNullable ? '?' : '';
      const nullable = col.isNullable || this.isAutoGenerated(col) ? ' | null' : '';
      ts += `          ${col.columnName}${optional}: ${tsType}${nullable};\n`;
    }
    ts += '        };\n';

    // Update type (all fields optional)
    ts += '        Update: {\n';
    for (const col of columns) {
      const tsType = this.postgresTypeToTS(col.dataType);
      const nullable = col.isNullable ? ' | null' : '';
      ts += `          ${col.columnName}?: ${tsType}${nullable};\n`;
    }
    ts += '        };\n';

    ts += '      };\n';

    return ts;
  }

  /**
   * Map PostgreSQL type to TypeScript type
   */
  private postgresTypeToTS(pgType: string): string {
    const typeMap: Record<string, string> = {
      // Text types
      'character varying': 'string',
      varchar: 'string',
      text: 'string',
      char: 'string',
      character: 'string',
      // Numeric types
      integer: 'number',
      int: 'number',
      int4: 'number',
      bigint: 'number',
      int8: 'number',
      smallint: 'number',
      int2: 'number',
      decimal: 'number',
      numeric: 'number',
      real: 'number',
      float4: 'number',
      'double precision': 'number',
      float8: 'number',
      serial: 'number',
      bigserial: 'number',
      // Boolean
      boolean: 'boolean',
      bool: 'boolean',
      // Date/Time types
      timestamp: 'string',
      'timestamp with time zone': 'string',
      'timestamp without time zone': 'string',
      timestamptz: 'string',
      date: 'string',
      time: 'string',
      'time with time zone': 'string',
      'time without time zone': 'string',
      timetz: 'string',
      interval: 'string',
      // UUID
      uuid: 'string',
      // JSON
      json: 'Record<string, any>',
      jsonb: 'Record<string, any>',
      // Array (simplified)
      'ARRAY': 'any[]',
    };

    // Handle array types
    if (pgType.startsWith('ARRAY') || pgType.endsWith('[]')) {
      const baseType = pgType.replace('ARRAY', '').replace('[]', '').trim();
      const tsBaseType = typeMap[baseType.toLowerCase()] || 'any';
      return `${tsBaseType}[]`;
    }

    return typeMap[pgType.toLowerCase()] || 'any';
  }

  /**
   * Check if a column is auto-generated
   */
  private isAutoGenerated(col: ColumnInfo): boolean {
    if (!col.columnDefault) return false;

    const defaultLower = col.columnDefault.toLowerCase();

    // UUID generation
    if (defaultLower.includes('uuid_generate') || defaultLower.includes('gen_random_uuid')) {
      return true;
    }

    // Serial/sequence
    if (defaultLower.includes('nextval')) {
      return true;
    }

    // Timestamp defaults
    if (
      (col.columnName.toLowerCase().includes('created') ||
        col.columnName.toLowerCase().includes('updated')) &&
      defaultLower.includes('now()')
    ) {
      return true;
    }

    return false;
  }
}
