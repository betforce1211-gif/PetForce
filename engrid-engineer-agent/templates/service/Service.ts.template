// =============================================================================
// Service Template: {{SERVICE_NAME}}Service
// Generated by Engrid - Build it once, build it right, build it to last
// =============================================================================

import { config } from '@/config';
import { logger } from '@/infrastructure/logger';
import { CacheService } from '@/infrastructure/cache';
import { EventEmitter } from '@/infrastructure/events';
import type { 
  {{SERVICE_NAME}}, 
  Create{{SERVICE_NAME}}DTO, 
  Update{{SERVICE_NAME}}DTO,
  {{SERVICE_NAME}}Repository,
} from './types';

// =============================================================================
// CONFIGURATION
// =============================================================================

interface {{SERVICE_NAME}}ServiceConfig {
  cacheEnabled: boolean;
  cacheTTLSeconds: number;
  maxRetries: number;
  retryDelayMs: number;
}

const defaultConfig: {{SERVICE_NAME}}ServiceConfig = {
  cacheEnabled: true,
  cacheTTLSeconds: 300,      // 5 minutes
  maxRetries: 3,
  retryDelayMs: 1000,
};

// =============================================================================
// SERVICE
// =============================================================================

/**
 * {{SERVICE_NAME}}Service - Handles all {{SERVICE_NAME}} business logic
 * 
 * @description
 * This service encapsulates all business logic related to {{SERVICE_NAME}}.
 * It uses dependency injection for testability and follows the 
 * repository pattern for data access.
 * 
 * @example
 * ```typescript
 * const service = new {{SERVICE_NAME}}Service(repository, cache, events);
 * const item = await service.findById('123');
 * ```
 */
export class {{SERVICE_NAME}}Service {
  private readonly config: {{SERVICE_NAME}}ServiceConfig;
  private readonly logger = logger.child({ service: '{{SERVICE_NAME}}Service' });

  constructor(
    private readonly repository: {{SERVICE_NAME}}Repository,
    private readonly cache: CacheService,
    private readonly events: EventEmitter,
    configOverrides?: Partial<{{SERVICE_NAME}}ServiceConfig>,
  ) {
    // Merge default config with any overrides (fully configurable!)
    this.config = {
      ...defaultConfig,
      ...config.get('services.{{serviceName}}', {}),
      ...configOverrides,
    };
    
    this.logger.info('{{SERVICE_NAME}}Service initialized', { config: this.config });
  }

  // ===========================================================================
  // PUBLIC METHODS
  // ===========================================================================

  /**
   * Find a {{SERVICE_NAME}} by ID
   * 
   * @param id - The unique identifier
   * @returns The {{SERVICE_NAME}} or null if not found
   * 
   * @example
   * ```typescript
   * const item = await service.findById('123');
   * if (item) {
   *   console.log(item.name);
   * }
   * ```
   */
  async findById(id: string): Promise<{{SERVICE_NAME}} | null> {
    this.logger.debug('Finding {{SERVICE_NAME}} by ID', { id });

    // Check cache first (if enabled)
    if (this.config.cacheEnabled) {
      const cached = await this.cache.get<{{SERVICE_NAME}}>(this.getCacheKey(id));
      if (cached) {
        this.logger.debug('Cache hit for {{SERVICE_NAME}}', { id });
        return cached;
      }
    }

    // Fetch from repository
    const item = await this.repository.findById(id);
    
    // Cache the result
    if (item && this.config.cacheEnabled) {
      await this.cache.set(
        this.getCacheKey(id), 
        item, 
        this.config.cacheTTLSeconds
      );
    }

    return item;
  }

  /**
   * Find all {{SERVICE_NAME}}s with optional filtering
   * 
   * @param options - Query options (pagination, filters, sorting)
   * @returns Paginated list of {{SERVICE_NAME}}s
   */
  async findAll(options?: FindAllOptions): Promise<PaginatedResult<{{SERVICE_NAME}}>> {
    this.logger.debug('Finding all {{SERVICE_NAME}}s', { options });

    const {
      page = 1,
      pageSize = config.get('pagination.defaultPageSize', 20),
      sortBy = 'createdAt',
      sortOrder = 'desc',
      filters = {},
    } = options ?? {};

    // Validate pagination
    const validatedPageSize = Math.min(
      pageSize, 
      config.get('pagination.maxPageSize', 100)
    );

    return this.repository.findAll({
      page,
      pageSize: validatedPageSize,
      sortBy,
      sortOrder,
      filters,
    });
  }

  /**
   * Create a new {{SERVICE_NAME}}
   * 
   * @param dto - The creation data
   * @returns The created {{SERVICE_NAME}}
   * @throws {ValidationError} If the data is invalid
   */
  async create(dto: Create{{SERVICE_NAME}}DTO): Promise<{{SERVICE_NAME}}> {
    this.logger.info('Creating {{SERVICE_NAME}}', { dto });

    // Validate input (always validate on the server!)
    this.validate(dto);

    // Create in repository
    const item = await this.repository.create(dto);

    // Emit event (for other services to react)
    await this.events.emit('{{serviceName}}.created', { item });

    this.logger.info('{{SERVICE_NAME}} created', { id: item.id });

    return item;
  }

  /**
   * Update an existing {{SERVICE_NAME}}
   * 
   * @param id - The ID of the {{SERVICE_NAME}} to update
   * @param dto - The update data
   * @returns The updated {{SERVICE_NAME}}
   * @throws {NotFoundError} If the {{SERVICE_NAME}} doesn't exist
   */
  async update(id: string, dto: Update{{SERVICE_NAME}}DTO): Promise<{{SERVICE_NAME}}> {
    this.logger.info('Updating {{SERVICE_NAME}}', { id, dto });

    // Verify exists
    const existing = await this.findById(id);
    if (!existing) {
      throw new NotFoundError('{{SERVICE_NAME}}', id);
    }

    // Validate input
    this.validate(dto, true);

    // Update in repository
    const updated = await this.repository.update(id, dto);

    // Invalidate cache
    await this.invalidateCache(id);

    // Emit event
    await this.events.emit('{{serviceName}}.updated', { 
      item: updated, 
      changes: dto 
    });

    this.logger.info('{{SERVICE_NAME}} updated', { id });

    return updated;
  }

  /**
   * Delete a {{SERVICE_NAME}}
   * 
   * @param id - The ID of the {{SERVICE_NAME}} to delete
   * @throws {NotFoundError} If the {{SERVICE_NAME}} doesn't exist
   */
  async delete(id: string): Promise<void> {
    this.logger.info('Deleting {{SERVICE_NAME}}', { id });

    // Verify exists
    const existing = await this.findById(id);
    if (!existing) {
      throw new NotFoundError('{{SERVICE_NAME}}', id);
    }

    // Delete from repository
    await this.repository.delete(id);

    // Invalidate cache
    await this.invalidateCache(id);

    // Emit event
    await this.events.emit('{{serviceName}}.deleted', { id });

    this.logger.info('{{SERVICE_NAME}} deleted', { id });
  }

  // ===========================================================================
  // PRIVATE METHODS
  // ===========================================================================

  /**
   * Validate {{SERVICE_NAME}} data
   */
  private validate(
    dto: Create{{SERVICE_NAME}}DTO | Update{{SERVICE_NAME}}DTO, 
    isPartial = false
  ): void {
    // Add validation logic here
    // Consider using a validation library like zod or joi
  }

  /**
   * Generate cache key for a {{SERVICE_NAME}}
   */
  private getCacheKey(id: string): string {
    return `{{serviceName}}:${id}`;
  }

  /**
   * Invalidate cache for a {{SERVICE_NAME}}
   */
  private async invalidateCache(id: string): Promise<void> {
    if (this.config.cacheEnabled) {
      await this.cache.delete(this.getCacheKey(id));
    }
  }

  /**
   * Retry an operation with exponential backoff
   */
  private async withRetry<T>(
    operation: () => Promise<T>,
    operationName: string
  ): Promise<T> {
    let lastError: Error | undefined;
    
    for (let attempt = 1; attempt <= this.config.maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error as Error;
        this.logger.warn(`${operationName} failed, attempt ${attempt}`, { 
          error: lastError.message 
        });
        
        if (attempt < this.config.maxRetries) {
          const delay = this.config.retryDelayMs * Math.pow(2, attempt - 1);
          await this.sleep(delay);
        }
      }
    }
    
    throw lastError;
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// =============================================================================
// TYPES
// =============================================================================

interface FindAllOptions {
  page?: number;
  pageSize?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
  filters?: Record<string, unknown>;
}

interface PaginatedResult<T> {
  data: T[];
  total: number;
  page: number;
  pageSize: number;
  totalPages: number;
}

// =============================================================================
// FACTORY (for dependency injection containers)
// =============================================================================

export function create{{SERVICE_NAME}}Service(
  repository: {{SERVICE_NAME}}Repository,
  cache: CacheService,
  events: EventEmitter,
): {{SERVICE_NAME}}Service {
  return new {{SERVICE_NAME}}Service(repository, cache, events);
}
