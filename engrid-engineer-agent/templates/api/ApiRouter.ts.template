// =============================================================================
// API Endpoint Template: {{RESOURCE_NAME}}
// Generated by Engrid - Build it once, build it right, build it to last
// =============================================================================

import { Router, Request, Response, NextFunction } from 'express';
import { z } from 'zod';
import { config } from '@/config';
import { logger } from '@/infrastructure/logger';
import { {{RESOURCE_NAME}}Service } from '@/core/services/{{resourceName}}';
import { 
  asyncHandler, 
  validateRequest, 
  requireAuth, 
  rateLimit,
  cacheResponse,
} from '@/infrastructure/middleware';
import { 
  ApiError, 
  NotFoundError, 
  ValidationError 
} from '@/shared/errors';

// =============================================================================
// CONFIGURATION
// =============================================================================

const apiConfig = {
  // All limits are configurable!
  defaultPageSize: config.get('api.pagination.defaultPageSize', 20),
  maxPageSize: config.get('api.pagination.maxPageSize', 100),
  rateLimitPerMinute: config.get('api.rateLimit.requestsPerMinute', 100),
  cacheTTLSeconds: config.get('api.cache.ttlSeconds', 60),
};

// =============================================================================
// VALIDATION SCHEMAS
// =============================================================================

const Create{{RESOURCE_NAME}}Schema = z.object({
  name: z.string().min(1).max(255),
  description: z.string().max(1000).optional(),
  // Add more fields as needed
}).strict();

const Update{{RESOURCE_NAME}}Schema = z.object({
  name: z.string().min(1).max(255).optional(),
  description: z.string().max(1000).optional(),
  // Add more fields as needed
}).strict();

const Query{{RESOURCE_NAME}}Schema = z.object({
  page: z.coerce.number().int().positive().default(1),
  pageSize: z.coerce.number().int().positive().max(apiConfig.maxPageSize).default(apiConfig.defaultPageSize),
  sortBy: z.enum(['createdAt', 'updatedAt', 'name']).default('createdAt'),
  sortOrder: z.enum(['asc', 'desc']).default('desc'),
  search: z.string().max(100).optional(),
}).strict();

const IdParamSchema = z.object({
  id: z.string().uuid(),
});

// =============================================================================
// ROUTER FACTORY
// =============================================================================

/**
 * Create {{RESOURCE_NAME}} API router
 * 
 * @param service - The {{RESOURCE_NAME}} service instance
 * @returns Express router with all {{RESOURCE_NAME}} endpoints
 * 
 * @example
 * ```typescript
 * const router = create{{RESOURCE_NAME}}Router({{resourceName}}Service);
 * app.use('/api/v1/{{resourceNamePlural}}', router);
 * ```
 */
export function create{{RESOURCE_NAME}}Router(service: {{RESOURCE_NAME}}Service): Router {
  const router = Router();
  const log = logger.child({ module: '{{RESOURCE_NAME}}API' });

  // ===========================================================================
  // MIDDLEWARE
  // ===========================================================================

  // Apply rate limiting to all routes
  router.use(rateLimit({
    windowMs: 60 * 1000,
    max: apiConfig.rateLimitPerMinute,
  }));

  // ===========================================================================
  // ROUTES
  // ===========================================================================

  /**
   * @openapi
   * /api/v1/{{resourceNamePlural}}:
   *   get:
   *     summary: List all {{resourceNamePlural}}
   *     tags: [{{RESOURCE_NAME}}]
   *     parameters:
   *       - in: query
   *         name: page
   *         schema:
   *           type: integer
   *           minimum: 1
   *           default: 1
   *       - in: query
   *         name: pageSize
   *         schema:
   *           type: integer
   *           minimum: 1
   *           maximum: 100
   *           default: 20
   *       - in: query
   *         name: sortBy
   *         schema:
   *           type: string
   *           enum: [createdAt, updatedAt, name]
   *       - in: query
   *         name: sortOrder
   *         schema:
   *           type: string
   *           enum: [asc, desc]
   *     responses:
   *       200:
   *         description: List of {{resourceNamePlural}}
   *         content:
   *           application/json:
   *             schema:
   *               $ref: '#/components/schemas/{{RESOURCE_NAME}}List'
   */
  router.get(
    '/',
    requireAuth(),
    validateRequest({ query: Query{{RESOURCE_NAME}}Schema }),
    cacheResponse({ ttl: apiConfig.cacheTTLSeconds }),
    asyncHandler(async (req: Request, res: Response) => {
      log.debug('Listing {{resourceNamePlural}}', { query: req.query });

      const result = await service.findAll({
        page: req.query.page as number,
        pageSize: req.query.pageSize as number,
        sortBy: req.query.sortBy as string,
        sortOrder: req.query.sortOrder as 'asc' | 'desc',
        filters: {
          search: req.query.search,
        },
      });

      res.json({
        data: result.data,
        meta: {
          page: result.page,
          pageSize: result.pageSize,
          total: result.total,
          totalPages: result.totalPages,
        },
      });
    })
  );

  /**
   * @openapi
   * /api/v1/{{resourceNamePlural}}/{id}:
   *   get:
   *     summary: Get a {{resourceName}} by ID
   *     tags: [{{RESOURCE_NAME}}]
   *     parameters:
   *       - in: path
   *         name: id
   *         required: true
   *         schema:
   *           type: string
   *           format: uuid
   *     responses:
   *       200:
   *         description: The {{resourceName}}
   *         content:
   *           application/json:
   *             schema:
   *               $ref: '#/components/schemas/{{RESOURCE_NAME}}'
   *       404:
   *         description: {{RESOURCE_NAME}} not found
   */
  router.get(
    '/:id',
    requireAuth(),
    validateRequest({ params: IdParamSchema }),
    cacheResponse({ ttl: apiConfig.cacheTTLSeconds }),
    asyncHandler(async (req: Request, res: Response) => {
      const { id } = req.params;
      log.debug('Getting {{resourceName}}', { id });

      const item = await service.findById(id);
      
      if (!item) {
        throw new NotFoundError('{{RESOURCE_NAME}}', id);
      }

      res.json({ data: item });
    })
  );

  /**
   * @openapi
   * /api/v1/{{resourceNamePlural}}:
   *   post:
   *     summary: Create a new {{resourceName}}
   *     tags: [{{RESOURCE_NAME}}]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             $ref: '#/components/schemas/Create{{RESOURCE_NAME}}'
   *     responses:
   *       201:
   *         description: {{RESOURCE_NAME}} created
   *         content:
   *           application/json:
   *             schema:
   *               $ref: '#/components/schemas/{{RESOURCE_NAME}}'
   *       400:
   *         description: Validation error
   */
  router.post(
    '/',
    requireAuth(),
    validateRequest({ body: Create{{RESOURCE_NAME}}Schema }),
    asyncHandler(async (req: Request, res: Response) => {
      log.info('Creating {{resourceName}}', { body: req.body });

      const item = await service.create({
        ...req.body,
        createdBy: req.user!.id,
      });

      res.status(201).json({ data: item });
    })
  );

  /**
   * @openapi
   * /api/v1/{{resourceNamePlural}}/{id}:
   *   patch:
   *     summary: Update a {{resourceName}}
   *     tags: [{{RESOURCE_NAME}}]
   *     parameters:
   *       - in: path
   *         name: id
   *         required: true
   *         schema:
   *           type: string
   *           format: uuid
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             $ref: '#/components/schemas/Update{{RESOURCE_NAME}}'
   *     responses:
   *       200:
   *         description: {{RESOURCE_NAME}} updated
   *       404:
   *         description: {{RESOURCE_NAME}} not found
   */
  router.patch(
    '/:id',
    requireAuth(),
    validateRequest({ 
      params: IdParamSchema, 
      body: Update{{RESOURCE_NAME}}Schema 
    }),
    asyncHandler(async (req: Request, res: Response) => {
      const { id } = req.params;
      log.info('Updating {{resourceName}}', { id, body: req.body });

      const item = await service.update(id, {
        ...req.body,
        updatedBy: req.user!.id,
      });

      res.json({ data: item });
    })
  );

  /**
   * @openapi
   * /api/v1/{{resourceNamePlural}}/{id}:
   *   delete:
   *     summary: Delete a {{resourceName}}
   *     tags: [{{RESOURCE_NAME}}]
   *     parameters:
   *       - in: path
   *         name: id
   *         required: true
   *         schema:
   *           type: string
   *           format: uuid
   *     responses:
   *       204:
   *         description: {{RESOURCE_NAME}} deleted
   *       404:
   *         description: {{RESOURCE_NAME}} not found
   */
  router.delete(
    '/:id',
    requireAuth(),
    validateRequest({ params: IdParamSchema }),
    asyncHandler(async (req: Request, res: Response) => {
      const { id } = req.params;
      log.info('Deleting {{resourceName}}', { id });

      await service.delete(id);

      res.status(204).send();
    })
  );

  return router;
}

// =============================================================================
// ERROR HANDLER (if not using global)
// =============================================================================

export function {{resourceName}}ErrorHandler(
  error: Error,
  req: Request,
  res: Response,
  next: NextFunction
): void {
  const log = logger.child({ module: '{{RESOURCE_NAME}}API' });
  
  log.error('{{RESOURCE_NAME}} API error', {
    error: error.message,
    stack: error.stack,
    path: req.path,
    method: req.method,
  });

  if (error instanceof ApiError) {
    res.status(error.statusCode).json({
      error: {
        code: error.code,
        message: error.message,
        details: error.details,
      },
    });
    return;
  }

  // Don't leak internal errors
  res.status(500).json({
    error: {
      code: 'INTERNAL_ERROR',
      message: 'An unexpected error occurred',
    },
  });
}
