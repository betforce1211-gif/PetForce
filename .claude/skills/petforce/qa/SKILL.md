# PetForce QA Testing Skill

## Overview

This skill provides comprehensive QA testing knowledge, processes, and templates for the PetForce project. It includes testing checklists, test templates for different test types, QA processes, and test coverage requirements.

## Testing Checklists

### Pre-Release Quality Checklist

**Version**: 1.0
**Feature**: [Feature Name]
**Date**: [YYYY-MM-DD]
**Reviewer**: Tucker (QA)

#### Test Coverage
- [ ] Happy path tested with all core scenarios
- [ ] Sad paths tested (errors, failures, invalid inputs)
- [ ] Edge cases identified and tested (boundaries, nulls, empties)
- [ ] All error paths have corresponding test cases

#### Test Quality & Maintainability
- [ ] Coverage meets thresholds (80% line, 75% branch, 85% function)
- [ ] Tests are clear, readable, and maintainable
- [ ] Test scenarios documented with descriptions
- [ ] No flaky tests (or quarantined if unavoidable)

#### Security Testing
- [ ] Input validation tested (XSS, SQL injection, path traversal)
- [ ] Authentication tested (valid, invalid, expired tokens)
- [ ] Authorization tested (access control, privilege escalation)
- [ ] Sensitive data handling verified

#### Test Types Coverage
- [ ] Unit tests written for business logic
- [ ] Integration tests for component interactions
- [ ] E2E tests for critical user journeys
- [ ] API tests for endpoint contracts

#### Regression & Automation
- [ ] Full regression suite executed
- [ ] All tests automated (no manual tests required)
- [ ] Tests run in CI/CD pipeline
- [ ] Test data properly managed and isolated

#### Edge Cases Testing
- [ ] Boundary values tested (0, -1, MAX, MIN)
- [ ] Null and undefined handling tested
- [ ] Empty collections tested
- [ ] Concurrent operations tested
- [ ] Timeout scenarios tested

## Test Templates

### Unit Test Template

```javascript
/**
 * Unit tests for [ServiceName]
 * Generated by Tucker
 */

describe('[ServiceName]', () => {
  let service;

  beforeEach(() => {
    // Setup
    service = new ServiceName();
  });

  afterEach(() => {
    // Cleanup
    jest.clearAllMocks();
  });

  describe('initialization', () => {
    it('should create instance with default config', () => {
      expect(service).toBeDefined();
    });

    it('should accept custom config', () => {
      const custom = new ServiceName({ option: 'value' });
      expect(custom.config.option).toBe('value');
    });
  });

  describe('primary method', () => {
    describe('happy path', () => {
      it('should succeed with valid input', async () => {
        // Arrange
        const input = { /* valid input */ };

        // Act
        const result = await service.method(input);

        // Assert
        expect(result).toBeDefined();
      });
    });

    describe('error handling', () => {
      it('should throw on invalid input', async () => {
        await expect(service.method(null))
          .rejects.toThrow('Invalid input');
      });
    });

    describe('edge cases', () => {
      it('should handle empty input', async () => {
        // Tucker always tests edge cases!
      });

      it('should handle null input', async () => {
        // Test null handling
      });

      it('should handle undefined input', async () => {
        // Test undefined handling
      });
    });
  });
});
```

### Integration Test Template

```javascript
/**
 * Integration tests for [ServiceName]
 * Generated by Tucker
 */

describe('[ServiceName] + [Dependency] Integration', () => {
  let db;
  let service;

  beforeAll(async () => {
    db = await TestDatabase.start();
    service = new ServiceName(db);
  });

  afterAll(async () => {
    await db.stop();
  });

  beforeEach(async () => {
    await db.clean(); // Clean slate for each test
  });

  describe('primary operation', () => {
    it('should persist changes to database', async () => {
      const input = {
        // Valid test data
      };

      const result = await service.operation(input);

      // Verify directly in database
      const dbRecord = await db.query(
        'SELECT * FROM table WHERE id = ?',
        [result.id]
      );
      expect(dbRecord).toBeDefined();
    });

    it('should handle database connection failure', async () => {
      await db.disconnect();

      await expect(service.operation({
        // Input data
      })).rejects.toThrow('Database unavailable');

      await db.connect(); // Restore for other tests
    });

    it('should rollback on transaction failure', async () => {
      // Test transaction rollback scenario
    });
  });
});
```

### E2E Test Template

```javascript
/**
 * E2E Test: [JourneyName]
 * Generated by Tucker
 */

import { test, expect } from '@playwright/test';

test.describe('[JourneyName]', () => {
  test.beforeEach(async ({ page }) => {
    // Setup: navigate to starting point
    await page.goto('/');
  });

  test('complete journey - happy path', async ({ page }) => {
    // Step 1: [Action]
    await page.click('[data-testid="button"]');

    // Step 2: [Action]
    await page.fill('[name="field"]', 'value');

    // Verify success
    await expect(page.locator('[data-testid="success"]')).toBeVisible();
  });

  test('handles errors gracefully', async ({ page }) => {
    // Simulate error condition

    // Verify error handling
    await expect(page.locator('[data-testid="error"]')).toBeVisible();
  });

  test('works on mobile viewport', async ({ page }) => {
    await page.setViewportSize({ width: 375, height: 667 });

    // Repeat critical path for mobile
  });
});
```

### API Test Template

```javascript
/**
 * API tests for [EndpointName]
 * Generated by Tucker
 */

describe('POST /api/[endpoint]', () => {
  describe('successful creation', () => {
    it('should return 201 with data', async () => {
      const response = await api.post('/[endpoint]', {
        // Valid request body
      });

      expect(response.status).toBe(201);
      expect(response.body).toMatchObject({
        id: expect.any(String),
        // Other expected fields
      });
    });
  });

  describe('validation errors', () => {
    it('should return 400 for missing required field', async () => {
      const response = await api.post('/[endpoint]', {
        // Missing required field
      });

      expect(response.status).toBe(400);
      expect(response.body.errors).toBeDefined();
    });

    it('should return 400 for invalid format', async () => {
      const response = await api.post('/[endpoint]', {
        field: 'invalid-format'
      });

      expect(response.status).toBe(400);
    });
  });

  describe('edge cases Tucker always tests', () => {
    it('should handle emoji in input', async () => {
      const response = await api.post('/[endpoint]', {
        field: 'Test ðŸš€ Value'
      });

      expect(response.status).toBe(201);
    });

    it('should handle max length inputs', async () => {
      const response = await api.post('/[endpoint]', {
        field: 'A'.repeat(255)
      });

      expect(response.status).toBe(201);
    });

    it('should reject oversized inputs', async () => {
      const response = await api.post('/[endpoint]', {
        field: 'A'.repeat(256)
      });

      expect(response.status).toBe(400);
    });

    it('should sanitize XSS attempts', async () => {
      const response = await api.post('/[endpoint]', {
        field: '<script>alert("xss")</script>'
      });

      if (response.status === 201) {
        expect(response.body.field).not.toContain('<script>');
      }
    });

    it('should handle SQL injection attempts', async () => {
      const response = await api.post('/[endpoint]', {
        field: "'; DROP TABLE users; --"
      });

      // Should either reject or safely handle
      expect([400, 201]).toContain(response.status);
    });
  });

  describe('authentication', () => {
    it('should return 401 without auth token', async () => {
      const response = await api.post('/[endpoint]', {
        // Request body
      }, { auth: false });

      expect(response.status).toBe(401);
    });

    it('should return 401 with expired token', async () => {
      const response = await api.post('/[endpoint]', {
        // Request body
      }, { token: EXPIRED_TOKEN });

      expect(response.status).toBe(401);
    });
  });
});
```

## Edge Case Categories

Tucker hunts these edge cases on every feature:

### Numeric Boundaries
- Zero
- Negative numbers
- MAX_INT / MIN_INT
- Floating point precision
- NaN, Infinity
- Leading zeros
- Scientific notation
- Currency edge cases

### String Boundaries
- Empty string ""
- Single character
- Max length
- Max length + 1
- Unicode (emoji, RTL)
- Special chars (!@#$%^&*)
- SQL injection strings
- XSS payloads

### Collection Edges
- Empty array/list
- Single element
- Exactly at limit
- One over limit
- Duplicates
- Null elements
- Out of order
- Circular references

### Date/Time Edges
- Leap years (Feb 29)
- Daylight saving time
- Year boundaries
- Timezone conversions
- Unix epoch edge cases
- Far future dates
- Invalid dates (Feb 30)

### State Transitions
- Empty â†’ populated
- Single â†’ multiple
- Active â†’ deleted
- Pending â†’ complete
- Concurrent modifications
- Race conditions
- Interrupted operations

### Network Conditions
- Timeout
- Connection lost mid-request
- Slow connection (3G)
- DNS failure
- SSL certificate issues
- Retry scenarios
- Partial response

### Auth/Permission Edges
- Expired token
- Invalid token format
- Wrong user's data
- Revoked permissions
- Concurrent sessions
- Role transitions

### Data Edges
- Null values
- Missing required fields
- Duplicate keys
- Orphaned records
- Circular dependencies
- Max storage reached

## Security Test Payloads

### XSS Payloads
```javascript
const xssTests = [
  '<script>alert(1)</script>',
  '<img src=x onerror=alert(1)>',
  '"><script>alert(1)</script>',
  "'-alert(1)-'",
  '<svg onload=alert(1)>',
];
```

### SQL Injection Payloads
```javascript
const sqlTests = [
  "' OR '1'='1",
  "'; DROP TABLE users; --",
  "' UNION SELECT * FROM users --",
  "1; UPDATE users SET role='admin'",
];
```

### Path Traversal Payloads
```javascript
const pathTests = [
  '../../../etc/passwd',
  '..\\..\\..\\windows\\system32',
];
```

## QA Processes

### Test Creation Process
1. Ask: "What's the happy path?"
2. Ask: "What could go wrong?"
3. Generate tests for:
   - Normal operation
   - Edge cases (boundaries, nulls, empties)
   - Error conditions
   - Security scenarios
   - Performance under load

### Regression Testing Levels

#### Smoke Tests (Every Commit)
- Duration: < 5 minutes
- App starts
- Can log in
- Critical path works
- No console errors

#### Core Regression (Every PR)
- Duration: < 30 minutes
- All unit tests
- Integration tests
- Core user journeys
- API contract tests

#### Full Regression (Before Release)
- Duration: < 2 hours
- Complete test suite
- Cross-browser testing
- Performance benchmarks
- Security scans
- Accessibility audit

#### Release Validation (After Deploy)
- Duration: < 15 minutes
- Production smoke tests
- Monitoring verification
- Rollback readiness

### Coverage Requirements

| Metric | Minimum | Target | Tucker's Standard |
|--------|---------|--------|-------------------|
| Line Coverage | 80% | 90% | 95%+ |
| Branch Coverage | 75% | 85% | 90%+ |
| Function Coverage | 85% | 95% | 100% |
| Critical Path Coverage | 100% | 100% | 100% |

### Critical Path Testing

Every release must verify these user journeys:

```yaml
critical_paths:
  - name: "New User Signup"
    steps:
      - Visit homepage
      - Click signup
      - Fill registration form
      - Verify email (or skip if test mode)
      - Complete onboarding
      - Reach dashboard

  - name: "Core Feature Usage"
    steps:
      - Login as existing user
      - Create new [primary object]
      - Edit [primary object]
      - Share [primary object]
      - Delete [primary object]

  - name: "Payment Flow"
    steps:
      - Select plan
      - Enter payment info
      - Process payment
      - Verify access granted
      - Verify receipt email

  - name: "Data Export"
    steps:
      - Navigate to settings
      - Request data export
      - Download export
      - Verify data integrity
```

## Test Data Management

### Test Data Factory Pattern

```javascript
const Factory = {
  user: (overrides = {}) => ({
    id: `user_${uuid()}`,
    email: `test-${uuid()}@example.com`,
    name: 'Test User',
    role: 'member',
    createdAt: new Date().toISOString(),
    ...overrides
  }),

  // Edge case variants
  edgeCases: {
    user: {
      withEmoji: () => Factory.user({ name: 'Test ðŸŽ‰ User' }),
      withLongName: () => Factory.user({ name: 'A'.repeat(255) }),
      withSpecialChars: () => Factory.user({ name: "O'Brien-Smith" }),
    }
  }
};
```

### Test Data Principles
1. **Isolation**: Each test manages its own data
2. **Repeatability**: Tests produce same results every run
3. **Realism**: Data resembles production (sanitized)
4. **Cleanup**: No test data pollution

## Tucker's Quality Gate

No release ships without passing Tucker's gate:

### Required to Pass
- [ ] All unit tests passing
- [ ] All integration tests passing
- [ ] All E2E critical paths passing
- [ ] Code coverage meets thresholds
- [ ] No high/critical security vulnerabilities
- [ ] Performance within baselines
- [ ] Full regression suite passing
- [ ] No new accessibility violations

### Metrics to Report
- Test execution time
- Coverage delta from last release
- New tests added
- Flaky test count
- Performance comparison

### Warnings (Review Required)
- Coverage decreased in any module
- New medium security findings
- Performance degradation > 10%
- Skipped tests increased

## Commands

### Test Execution
```bash
# Run all tests
tucker test all

# Run specific test suites
tucker test unit
tucker test integration
tucker test e2e
tucker test api
tucker test performance
tucker test security

# Run smoke tests (quick validation)
tucker test smoke

# Run regression suite
tucker test regression
```

### Test Creation
```bash
# Generate test file from template
tucker create unit "UserService"
tucker create integration "PaymentFlow"
tucker create e2e "CheckoutJourney"
tucker create api "UsersEndpoint"

# Generate edge case tests for a function
tucker generate edge-cases "calculateDiscount"
```

### Test Analysis
```bash
# Analyze test coverage
tucker coverage analyze

# Find untested code paths
tucker coverage gaps

# Identify flaky tests
tucker analyze flaky

# Security scan
tucker scan security
```

## Configuration

Tucker uses `.tucker.yml` in the repository root. Key settings:

```yaml
testing:
  frameworks:
    unit: 'jest'
    integration: 'jest'
    e2e: 'playwright'
    api: 'supertest'

coverage:
  global:
    lines: 80
    branches: 75
    functions: 85

  critical:
    paths: ['src/auth/**', 'src/payments/**']
    thresholds:
      lines: 95
      branches: 90
      functions: 100

regression:
  smoke:
    enabled: true
    timeout: 5m

  core:
    enabled: true
    timeout: 30m

  full:
    enabled: true
    timeout: 2h
```
