// =============================================================================
// Logger Template
// Generated by Larry - If it's not logged, it didn't happen
// =============================================================================

import { config } from '@/config';

// =============================================================================
// TYPES
// =============================================================================

type LogLevel = 'fatal' | 'error' | 'warn' | 'info' | 'debug' | 'trace';

interface LogContext {
  requestId?: string;
  traceId?: string;
  spanId?: string;
  userId?: string;
  sessionId?: string;
  [key: string]: unknown;
}

interface LogEntry {
  timestamp: string;
  level: string;
  message: string;
  service: string;
  environment: string;
  version: string;
  requestId?: string;
  traceId?: string;
  spanId?: string;
  userId?: string;
  error?: SerializedError;
  duration?: number;
  [key: string]: unknown;
}

interface SerializedError {
  name: string;
  message: string;
  code?: string;
  stack?: string;
  cause?: SerializedError;
}

interface LoggerConfig {
  level: LogLevel;
  format: 'json' | 'pretty';
  service: string;
  version: string;
  environment: string;
  redactFields: string[];
  redactPatterns: RegExp[];
  maxMessageLength: number;
}

// =============================================================================
// CONFIGURATION
// =============================================================================

const LOG_LEVELS: Record<LogLevel, number> = {
  fatal: 0,
  error: 1,
  warn: 2,
  info: 3,
  debug: 4,
  trace: 5,
};

const DEFAULT_REDACT_FIELDS = [
  'password',
  'passwd',
  'pwd',
  'token',
  'accessToken',
  'refreshToken',
  'apiKey',
  'api_key',
  'secretKey',
  'secret_key',
  'authorization',
  'bearer',
  'creditCard',
  'cardNumber',
  'cvv',
  'ssn',
  'socialSecurity',
];

const DEFAULT_REDACT_PATTERNS = [
  /\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b/g, // Credit card
  /\b\d{3}-\d{2}-\d{4}\b/g, // SSN
  /eyJ[A-Za-z0-9_-]*\.eyJ[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*/g, // JWT
];

const defaultConfig: LoggerConfig = {
  level: (config.get('logging.level', 'info') as LogLevel),
  format: (config.get('logging.format', 'json') as 'json' | 'pretty'),
  service: config.get('service.name', 'unknown'),
  version: config.get('service.version', '0.0.0'),
  environment: config.get('env', 'development'),
  redactFields: config.get('logging.redactFields', DEFAULT_REDACT_FIELDS),
  redactPatterns: DEFAULT_REDACT_PATTERNS,
  maxMessageLength: config.get('logging.maxMessageLength', 10000),
};

// =============================================================================
// LOGGER CLASS
// =============================================================================

class Logger {
  private config: LoggerConfig;
  private context: LogContext = {};

  constructor(loggerConfig: LoggerConfig = defaultConfig) {
    this.config = loggerConfig;
  }

  // ---------------------------------------------------------------------------
  // PUBLIC METHODS - LOG LEVELS
  // ---------------------------------------------------------------------------

  /**
   * Log a FATAL message - System is unusable
   */
  fatal(message: string, data?: Record<string, unknown>): void {
    this.log('fatal', message, data);
  }

  /**
   * Log an ERROR message - Operation failed
   */
  error(message: string, data?: Record<string, unknown>): void {
    this.log('error', message, data);
  }

  /**
   * Log a WARN message - Something unexpected but handled
   */
  warn(message: string, data?: Record<string, unknown>): void {
    this.log('warn', message, data);
  }

  /**
   * Log an INFO message - Business event or state change
   */
  info(message: string, data?: Record<string, unknown>): void {
    this.log('info', message, data);
  }

  /**
   * Log a DEBUG message - Diagnostic information
   */
  debug(message: string, data?: Record<string, unknown>): void {
    this.log('debug', message, data);
  }

  /**
   * Log a TRACE message - Very detailed debugging
   */
  trace(message: string, data?: Record<string, unknown>): void {
    this.log('trace', message, data);
  }

  // ---------------------------------------------------------------------------
  // PUBLIC METHODS - CONTEXT
  // ---------------------------------------------------------------------------

  /**
   * Create a child logger with additional context
   */
  child(context: LogContext): Logger {
    const childLogger = new Logger(this.config);
    childLogger.context = { ...this.context, ...context };
    return childLogger;
  }

  /**
   * Set context for this logger instance
   */
  setContext(context: LogContext): void {
    this.context = { ...this.context, ...context };
  }

  /**
   * Clear context
   */
  clearContext(): void {
    this.context = {};
  }

  // ---------------------------------------------------------------------------
  // PUBLIC METHODS - UTILITIES
  // ---------------------------------------------------------------------------

  /**
   * Log an error with proper serialization
   */
  logError(message: string, error: Error, context?: Record<string, unknown>): void {
    this.error(message, {
      error: this.serializeError(error),
      ...context,
    });
  }

  /**
   * Time an async operation and log the duration
   */
  async time<T>(
    name: string,
    fn: () => Promise<T>,
    context?: Record<string, unknown>
  ): Promise<T> {
    const start = Date.now();
    try {
      const result = await fn();
      const duration = Date.now() - start;
      this.info(`${name} completed`, { duration, ...context });
      return result;
    } catch (error) {
      const duration = Date.now() - start;
      this.error(`${name} failed`, {
        duration,
        error: this.serializeError(error as Error),
        ...context,
      });
      throw error;
    }
  }

  /**
   * Time a sync operation and log the duration
   */
  timeSync<T>(name: string, fn: () => T, context?: Record<string, unknown>): T {
    const start = Date.now();
    try {
      const result = fn();
      const duration = Date.now() - start;
      this.info(`${name} completed`, { duration, ...context });
      return result;
    } catch (error) {
      const duration = Date.now() - start;
      this.error(`${name} failed`, {
        duration,
        error: this.serializeError(error as Error),
        ...context,
      });
      throw error;
    }
  }

  // ---------------------------------------------------------------------------
  // PRIVATE METHODS
  // ---------------------------------------------------------------------------

  private log(level: LogLevel, message: string, data?: Record<string, unknown>): void {
    // Check if level is enabled
    if (!this.isLevelEnabled(level)) {
      return;
    }

    // Build log entry
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level: level.toUpperCase(),
      message: this.truncateMessage(message),
      service: this.config.service,
      environment: this.config.environment,
      version: this.config.version,
      ...this.context,
    };

    // Add data if provided (with redaction)
    if (data) {
      const redacted = this.redact(data);
      Object.assign(entry, redacted);
    }

    // Output
    this.output(level, entry);
  }

  private isLevelEnabled(level: LogLevel): boolean {
    return LOG_LEVELS[level] <= LOG_LEVELS[this.config.level];
  }

  private truncateMessage(message: string): string {
    if (message.length <= this.config.maxMessageLength) {
      return message;
    }
    return message.slice(0, this.config.maxMessageLength) + '... [truncated]';
  }

  private redact(obj: Record<string, unknown>): Record<string, unknown> {
    const result: Record<string, unknown> = {};

    for (const [key, value] of Object.entries(obj)) {
      // Check if key should be redacted
      const shouldRedactKey = this.config.redactFields.some((field) =>
        key.toLowerCase().includes(field.toLowerCase())
      );

      if (shouldRedactKey) {
        result[key] = '[REDACTED]';
        continue;
      }

      // Handle nested objects
      if (value !== null && typeof value === 'object' && !Array.isArray(value)) {
        result[key] = this.redact(value as Record<string, unknown>);
        continue;
      }

      // Handle arrays
      if (Array.isArray(value)) {
        result[key] = value.map((item) =>
          typeof item === 'object' && item !== null
            ? this.redact(item as Record<string, unknown>)
            : this.redactString(item)
        );
        continue;
      }

      // Handle strings - check for patterns
      if (typeof value === 'string') {
        result[key] = this.redactString(value);
        continue;
      }

      result[key] = value;
    }

    return result;
  }

  private redactString(value: unknown): unknown {
    if (typeof value !== 'string') {
      return value;
    }

    let result = value;
    for (const pattern of this.config.redactPatterns) {
      result = result.replace(pattern, '[REDACTED]');
    }
    return result;
  }

  private serializeError(error: Error): SerializedError {
    const serialized: SerializedError = {
      name: error.name,
      message: error.message,
    };

    // Include code if present
    if ('code' in error) {
      serialized.code = String((error as { code: unknown }).code);
    }

    // Include stack in non-production
    if (this.config.environment !== 'production') {
      serialized.stack = error.stack;
    }

    // Include cause if present (ES2022+)
    if ('cause' in error && error.cause instanceof Error) {
      serialized.cause = this.serializeError(error.cause);
    }

    return serialized;
  }

  private output(level: LogLevel, entry: LogEntry): void {
    const output =
      this.config.format === 'json'
        ? JSON.stringify(entry)
        : this.formatPretty(entry);

    // Route to appropriate console method
    switch (level) {
      case 'fatal':
      case 'error':
        console.error(output);
        break;
      case 'warn':
        console.warn(output);
        break;
      default:
        console.log(output);
    }
  }

  private formatPretty(entry: LogEntry): string {
    const colors: Record<string, string> = {
      FATAL: '\x1b[35m', // Magenta
      ERROR: '\x1b[31m', // Red
      WARN: '\x1b[33m',  // Yellow
      INFO: '\x1b[32m',  // Green
      DEBUG: '\x1b[36m', // Cyan
      TRACE: '\x1b[90m', // Gray
    };
    const reset = '\x1b[0m';
    const dim = '\x1b[2m';

    const { timestamp, level, message, service, ...rest } = entry;
    const color = colors[level] || '';

    let output = `${dim}${timestamp}${reset} ${color}${level.padEnd(5)}${reset} ${dim}[${service}]${reset} ${message}`;

    // Add additional fields if present
    const extraFields = Object.keys(rest).filter(
      (k) => !['environment', 'version'].includes(k)
    );
    if (extraFields.length > 0) {
      const extras: Record<string, unknown> = {};
      for (const key of extraFields) {
        extras[key] = rest[key];
      }
      output += `\n${dim}${JSON.stringify(extras, null, 2)}${reset}`;
    }

    return output;
  }
}

// =============================================================================
// SINGLETON EXPORT
// =============================================================================

export const logger = new Logger();

// =============================================================================
// TYPE EXPORTS
// =============================================================================

export type { Logger, LogLevel, LogContext, LogEntry, SerializedError };
