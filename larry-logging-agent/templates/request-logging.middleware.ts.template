// =============================================================================
// Request Logging Middleware Template
// Generated by Larry - If it's not logged, it didn't happen
// =============================================================================

import { Request, Response, NextFunction } from 'express';
import { v4 as uuidv4 } from 'uuid';
import { logger } from './logger';

// =============================================================================
// TYPES
// =============================================================================

interface RequestLogData {
  method: string;
  path: string;
  query: Record<string, unknown>;
  userAgent: string;
  ip: string;
  contentLength: number;
  userId?: string;
}

interface ResponseLogData extends RequestLogData {
  statusCode: number;
  duration: number;
  responseSize: number;
}

// Extend Express Request type
declare global {
  namespace Express {
    interface Request {
      requestId: string;
      traceId: string;
      spanId: string;
      log: typeof logger;
      startTime: bigint;
    }
  }
}

// =============================================================================
// UTILITIES
// =============================================================================

/**
 * Normalize URL path to prevent high cardinality in metrics
 * Replaces UUIDs and numeric IDs with placeholders
 */
function normalizePath(path: string): string {
  return path
    // Replace UUIDs
    .replace(
      /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/gi,
      ':id'
    )
    // Replace numeric IDs
    .replace(/\/\d+/g, '/:id')
    // Replace MongoDB ObjectIds
    .replace(/[0-9a-f]{24}/gi, ':id');
}

/**
 * Get client IP address from request
 */
function getClientIp(req: Request): string {
  const forwarded = req.headers['x-forwarded-for'];
  if (typeof forwarded === 'string') {
    return forwarded.split(',')[0].trim();
  }
  return req.ip || req.socket.remoteAddress || 'unknown';
}

/**
 * Get log level based on status code
 */
function getLogLevel(statusCode: number): 'error' | 'warn' | 'info' {
  if (statusCode >= 500) return 'error';
  if (statusCode >= 400) return 'warn';
  return 'info';
}

// =============================================================================
// MIDDLEWARE
// =============================================================================

/**
 * Request logging middleware
 * 
 * Adds request ID, trace ID, and request-scoped logger to every request.
 * Logs request received and response sent with timing.
 * 
 * @example
 * ```typescript
 * app.use(requestLoggingMiddleware);
 * 
 * app.get('/users/:id', (req, res) => {
 *   req.log.info('Fetching user', { userId: req.params.id });
 *   // ...
 * });
 * ```
 */
export function requestLoggingMiddleware(
  req: Request,
  res: Response,
  next: NextFunction
): void {
  // Generate or extract correlation IDs
  req.requestId = (req.headers['x-request-id'] as string) || uuidv4();
  req.traceId = (req.headers['x-trace-id'] as string) || uuidv4();
  req.spanId = uuidv4().split('-')[0]; // Short span ID

  // Set response headers for correlation
  res.setHeader('X-Request-Id', req.requestId);
  res.setHeader('X-Trace-Id', req.traceId);

  // Create request-scoped logger
  req.log = logger.child({
    requestId: req.requestId,
    traceId: req.traceId,
    spanId: req.spanId,
    userId: (req as any).user?.id,
  });

  // Record start time (high precision)
  req.startTime = process.hrtime.bigint();

  // Build request log data
  const requestData: RequestLogData = {
    method: req.method,
    path: req.path,
    query: req.query as Record<string, unknown>,
    userAgent: req.headers['user-agent'] || 'unknown',
    ip: getClientIp(req),
    contentLength: parseInt(req.headers['content-length'] || '0', 10),
    userId: (req as any).user?.id,
  };

  // Log request received
  req.log.info('Request received', {
    ...requestData,
    normalizedPath: normalizePath(req.path),
  });

  // Capture original end function
  const originalEnd = res.end;

  // Override end to log response
  res.end = function (
    chunk?: any,
    encoding?: BufferEncoding | (() => void),
    callback?: () => void
  ): Response {
    // Calculate duration
    const endTime = process.hrtime.bigint();
    const durationNs = endTime - req.startTime;
    const durationMs = Number(durationNs) / 1_000_000;

    // Build response log data
    const responseData: ResponseLogData = {
      ...requestData,
      statusCode: res.statusCode,
      duration: Math.round(durationMs * 100) / 100, // 2 decimal places
      responseSize: parseInt(res.getHeader('content-length') as string) || 0,
    };

    // Log at appropriate level
    const level = getLogLevel(res.statusCode);
    const message =
      level === 'error'
        ? 'Request failed'
        : level === 'warn'
        ? 'Request client error'
        : 'Request completed';

    req.log[level](message, {
      ...responseData,
      normalizedPath: normalizePath(req.path),
    });

    // Call original end
    return originalEnd.call(this, chunk, encoding as BufferEncoding, callback);
  };

  next();
}

/**
 * Error logging middleware
 * 
 * Logs errors with full context and stack trace.
 * Should be registered after all routes.
 * 
 * @example
 * ```typescript
 * app.use(routes);
 * app.use(errorLoggingMiddleware);
 * ```
 */
export function errorLoggingMiddleware(
  error: Error,
  req: Request,
  res: Response,
  next: NextFunction
): void {
  const log = req.log || logger;

  // Determine if operational error
  const isOperational = (error as any).isOperational === true;
  const statusCode = (error as any).statusCode || 500;

  // Log error with context
  log.error('Unhandled error', {
    error: {
      name: error.name,
      message: error.message,
      code: (error as any).code,
      stack: error.stack,
      isOperational,
    },
    request: {
      method: req.method,
      path: req.path,
      query: req.query,
      // Don't log body directly - it might have sensitive data
      bodyKeys: req.body ? Object.keys(req.body) : [],
    },
  });

  // Send error response (don't leak internals in production)
  res.status(statusCode).json({
    error: {
      message: isOperational ? error.message : 'An unexpected error occurred',
      code: (error as any).code || 'INTERNAL_ERROR',
      requestId: req.requestId,
    },
  });
}

/**
 * Health check endpoint (skip logging)
 * 
 * Use this to create health check routes that don't pollute logs.
 * 
 * @example
 * ```typescript
 * app.get('/health', skipLogging, (req, res) => {
 *   res.json({ status: 'ok' });
 * });
 * ```
 */
export function skipLogging(
  req: Request,
  res: Response,
  next: NextFunction
): void {
  // Mark request to skip logging
  (req as any).skipLogging = true;
  next();
}

// =============================================================================
// EXPORTS
// =============================================================================

export {
  normalizePath,
  getClientIp,
  getLogLevel,
};
