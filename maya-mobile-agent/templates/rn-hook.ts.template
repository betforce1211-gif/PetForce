/**
 * Maya's React Native Custom Hook Template
 * Mobile first isn't just a strategy. It's where your users live.
 *
 * This hook template includes:
 * - Data fetching with loading states
 * - Pagination support
 * - Pull-to-refresh
 * - Error handling
 * - Offline caching
 * - Optimistic updates
 */

import { useState, useCallback, useEffect, useRef } from 'react';
import { useNavigation } from '@react-navigation/native';
import { api } from '@/services/api';
import { storage } from '@/services/storage';
import { {{ITEM_TYPE}} } from '@/types';

// =============================================================================
// TYPES
// =============================================================================

interface Use{{FEATURE_NAME}}Return {
  // Data
  items: {{ITEM_TYPE}}[];
  
  // Loading states
  isLoading: boolean;
  isRefreshing: boolean;
  isLoadingMore: boolean;
  
  // Error
  error: string | null;
  
  // Pagination
  hasMore: boolean;
  
  // Actions
  refresh: () => Promise<void>;
  loadMore: () => Promise<void>;
  onItemPress: (item: {{ITEM_TYPE}}) => void;
  
  // Optional: Mutations
  addItem?: (item: {{ITEM_TYPE}}) => Promise<void>;
  updateItem?: (id: string, updates: Partial<{{ITEM_TYPE}}>) => Promise<void>;
  deleteItem?: (id: string) => Promise<void>;
}

interface FetchOptions {
  page: number;
  limit: number;
}

// =============================================================================
// CONSTANTS
// =============================================================================

const ITEMS_PER_PAGE = 20;
const CACHE_KEY = '{{FEATURE_NAME_LOWER}}_items';
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

// =============================================================================
// HOOK
// =============================================================================

export const use{{FEATURE_NAME}} = (): Use{{FEATURE_NAME}}Return => {
  const navigation = useNavigation();
  
  // ---------------------------------------------------------------------------
  // STATE
  // ---------------------------------------------------------------------------
  
  const [items, setItems] = useState<{{ITEM_TYPE}}[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [isLoadingMore, setIsLoadingMore] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(true);
  
  // Ref to track if component is mounted
  const isMounted = useRef(true);
  
  // ---------------------------------------------------------------------------
  // CACHE HELPERS
  // ---------------------------------------------------------------------------
  
  const loadFromCache = useCallback(async (): Promise<{{ITEM_TYPE}}[] | null> => {
    try {
      const cached = await storage.get(CACHE_KEY);
      if (cached) {
        const { data, timestamp } = JSON.parse(cached);
        // Check if cache is still valid
        if (Date.now() - timestamp < CACHE_TTL) {
          return data;
        }
      }
      return null;
    } catch {
      return null;
    }
  }, []);
  
  const saveToCache = useCallback(async (data: {{ITEM_TYPE}}[]) => {
    try {
      await storage.set(
        CACHE_KEY,
        JSON.stringify({ data, timestamp: Date.now() })
      );
    } catch {
      // Silently fail cache writes
    }
  }, []);
  
  // ---------------------------------------------------------------------------
  // FETCH FUNCTION
  // ---------------------------------------------------------------------------
  
  const fetchItems = useCallback(
    async (options: FetchOptions, isRefresh = false) => {
      try {
        // Set appropriate loading state
        if (isRefresh) {
          setIsRefreshing(true);
        } else if (options.page === 1) {
          setIsLoading(true);
        } else {
          setIsLoadingMore(true);
        }
        
        setError(null);
        
        // Fetch from API
        const response = await api.get{{FEATURE_NAME}}({
          page: options.page,
          limit: options.limit,
        });
        
        // Guard against updates after unmount
        if (!isMounted.current) return;
        
        const newItems = response.data;
        const hasMoreItems = newItems.length === options.limit;
        
        // Update state
        if (options.page === 1) {
          setItems(newItems);
          // Cache first page
          saveToCache(newItems);
        } else {
          setItems((prev) => [...prev, ...newItems]);
        }
        
        setPage(options.page);
        setHasMore(hasMoreItems);
        
      } catch (err) {
        if (!isMounted.current) return;
        
        const errorMessage =
          err instanceof Error ? err.message : 'An error occurred';
        setError(errorMessage);
        
        // On error, try to load from cache (offline support)
        if (options.page === 1) {
          const cached = await loadFromCache();
          if (cached) {
            setItems(cached);
            setError('Showing cached data. Pull to refresh.');
          }
        }
      } finally {
        if (isMounted.current) {
          setIsLoading(false);
          setIsRefreshing(false);
          setIsLoadingMore(false);
        }
      }
    },
    [loadFromCache, saveToCache]
  );
  
  // ---------------------------------------------------------------------------
  // ACTIONS
  // ---------------------------------------------------------------------------
  
  const refresh = useCallback(async () => {
    await fetchItems({ page: 1, limit: ITEMS_PER_PAGE }, true);
  }, [fetchItems]);
  
  const loadMore = useCallback(async () => {
    if (isLoadingMore || !hasMore) return;
    await fetchItems({ page: page + 1, limit: ITEMS_PER_PAGE });
  }, [fetchItems, isLoadingMore, hasMore, page]);
  
  const onItemPress = useCallback(
    (item: {{ITEM_TYPE}}) => {
      navigation.navigate('{{FEATURE_NAME}}Detail', { itemId: item.id });
    },
    [navigation]
  );
  
  // ---------------------------------------------------------------------------
  // MUTATIONS (Optional)
  // ---------------------------------------------------------------------------
  
  const addItem = useCallback(async (newItem: {{ITEM_TYPE}}) => {
    // Optimistic update
    setItems((prev) => [newItem, ...prev]);
    
    try {
      await api.create{{FEATURE_NAME}}Item(newItem);
    } catch (err) {
      // Revert on error
      setItems((prev) => prev.filter((item) => item.id !== newItem.id));
      throw err;
    }
  }, []);
  
  const updateItem = useCallback(
    async (id: string, updates: Partial<{{ITEM_TYPE}}>) => {
      // Store previous state for rollback
      const previousItems = items;
      
      // Optimistic update
      setItems((prev) =>
        prev.map((item) =>
          item.id === id ? { ...item, ...updates } : item
        )
      );
      
      try {
        await api.update{{FEATURE_NAME}}Item(id, updates);
      } catch (err) {
        // Revert on error
        setItems(previousItems);
        throw err;
      }
    },
    [items]
  );
  
  const deleteItem = useCallback(
    async (id: string) => {
      // Store previous state for rollback
      const previousItems = items;
      
      // Optimistic update
      setItems((prev) => prev.filter((item) => item.id !== id));
      
      try {
        await api.delete{{FEATURE_NAME}}Item(id);
      } catch (err) {
        // Revert on error
        setItems(previousItems);
        throw err;
      }
    },
    [items]
  );
  
  // ---------------------------------------------------------------------------
  // INITIAL LOAD
  // ---------------------------------------------------------------------------
  
  useEffect(() => {
    // Load cached data first for instant UI
    loadFromCache().then((cached) => {
      if (cached && isMounted.current) {
        setItems(cached);
        setIsLoading(false);
      }
    });
    
    // Then fetch fresh data
    fetchItems({ page: 1, limit: ITEMS_PER_PAGE });
    
    // Cleanup
    return () => {
      isMounted.current = false;
    };
  }, [fetchItems, loadFromCache]);
  
  // ---------------------------------------------------------------------------
  // RETURN
  // ---------------------------------------------------------------------------
  
  return {
    items,
    isLoading,
    isRefreshing,
    isLoadingMore,
    error,
    hasMore,
    refresh,
    loadMore,
    onItemPress,
    addItem,
    updateItem,
    deleteItem,
  };
};

export default use{{FEATURE_NAME}};
