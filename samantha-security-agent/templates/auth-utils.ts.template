// =============================================================================
// Samantha's Authentication Utilities
// Security is not a product, but a process.
// =============================================================================

import { randomBytes, scrypt, timingSafeEqual } from 'crypto';
import { promisify } from 'util';
import { SignJWT, jwtVerify, JWTPayload } from 'jose';
import { z } from 'zod';

const scryptAsync = promisify(scrypt);

// =============================================================================
// TYPES
// =============================================================================

interface HashedPassword {
  hash: string;
  salt: string;
}

interface TokenPayload extends JWTPayload {
  sub: string;
  email: string;
  roles: string[];
  type: 'access' | 'refresh';
}

interface TokenPair {
  accessToken: string;
  refreshToken: string;
  expiresIn: number;
}

// =============================================================================
// CONFIGURATION
// =============================================================================

const config = {
  // Password hashing (using scrypt for simplicity, Argon2id recommended in production)
  password: {
    keyLength: 64,
    saltLength: 32,
    cost: 16384,        // N
    blockSize: 8,       // r
    parallelization: 1, // p
  },
  
  // JWT settings
  jwt: {
    algorithm: 'HS256' as const, // Use RS256 in production
    accessTokenExpiry: '15m',
    refreshTokenExpiry: '7d',
    issuer: process.env.JWT_ISSUER || 'https://your-app.com',
    audience: process.env.JWT_AUDIENCE || 'https://your-app.com',
  },
};

// =============================================================================
// PASSWORD VALIDATION
// =============================================================================

/**
 * Password validation schema (NIST 800-63B compliant)
 */
export const passwordSchema = z
  .string()
  .min(12, 'Password must be at least 12 characters')
  .max(128, 'Password is too long')
  // Note: No complexity requirements per NIST guidelines
  // Length is more important than complexity
  .refine(
    (password) => !commonPasswords.has(password.toLowerCase()),
    'This password is too common'
  );

// Small set of common passwords to block
// In production, use a proper breached password database
const commonPasswords = new Set([
  'password123456',
  'qwertyuiop123',
  '123456789012',
  // Add more or use an API like HaveIBeenPwned
]);

/**
 * Validates password against policy
 */
export function validatePassword(password: string): { valid: boolean; errors: string[] } {
  const result = passwordSchema.safeParse(password);
  
  if (result.success) {
    return { valid: true, errors: [] };
  }
  
  return {
    valid: false,
    errors: result.error.errors.map(e => e.message),
  };
}

// =============================================================================
// PASSWORD HASHING
// =============================================================================

/**
 * Hashes a password using scrypt
 * In production, consider using Argon2id
 */
export async function hashPassword(password: string): Promise<HashedPassword> {
  const salt = randomBytes(config.password.saltLength);
  
  const hash = await scryptAsync(
    password,
    salt,
    config.password.keyLength,
    {
      N: config.password.cost,
      r: config.password.blockSize,
      p: config.password.parallelization,
    }
  ) as Buffer;
  
  return {
    hash: hash.toString('base64'),
    salt: salt.toString('base64'),
  };
}

/**
 * Verifies a password against a hash
 * Uses timing-safe comparison to prevent timing attacks
 */
export async function verifyPassword(
  password: string,
  storedHash: string,
  storedSalt: string
): Promise<boolean> {
  const salt = Buffer.from(storedSalt, 'base64');
  
  const hash = await scryptAsync(
    password,
    salt,
    config.password.keyLength,
    {
      N: config.password.cost,
      r: config.password.blockSize,
      p: config.password.parallelization,
    }
  ) as Buffer;
  
  const storedHashBuffer = Buffer.from(storedHash, 'base64');
  
  // Timing-safe comparison
  return timingSafeEqual(hash, storedHashBuffer);
}

// =============================================================================
// JWT TOKENS
// =============================================================================

/**
 * Gets the JWT secret key
 * In production, use RS256 with public/private key pair
 */
function getJwtSecret(): Uint8Array {
  const secret = process.env.JWT_SECRET;
  if (!secret || secret.length < 32) {
    throw new Error('JWT_SECRET must be at least 32 characters');
  }
  return new TextEncoder().encode(secret);
}

/**
 * Generates an access token
 */
export async function generateAccessToken(user: {
  id: string;
  email: string;
  roles: string[];
}): Promise<string> {
  const secret = getJwtSecret();
  
  return new SignJWT({
    email: user.email,
    roles: user.roles,
    type: 'access',
  })
    .setProtectedHeader({ alg: config.jwt.algorithm })
    .setSubject(user.id)
    .setIssuedAt()
    .setIssuer(config.jwt.issuer)
    .setAudience(config.jwt.audience)
    .setExpirationTime(config.jwt.accessTokenExpiry)
    .setJti(randomBytes(16).toString('hex'))
    .sign(secret);
}

/**
 * Generates a refresh token
 */
export async function generateRefreshToken(userId: string): Promise<string> {
  const secret = getJwtSecret();
  
  return new SignJWT({
    type: 'refresh',
  })
    .setProtectedHeader({ alg: config.jwt.algorithm })
    .setSubject(userId)
    .setIssuedAt()
    .setIssuer(config.jwt.issuer)
    .setAudience(config.jwt.audience)
    .setExpirationTime(config.jwt.refreshTokenExpiry)
    .setJti(randomBytes(16).toString('hex'))
    .sign(secret);
}

/**
 * Generates both access and refresh tokens
 */
export async function generateTokenPair(user: {
  id: string;
  email: string;
  roles: string[];
}): Promise<TokenPair> {
  const [accessToken, refreshToken] = await Promise.all([
    generateAccessToken(user),
    generateRefreshToken(user.id),
  ]);
  
  return {
    accessToken,
    refreshToken,
    expiresIn: 900, // 15 minutes in seconds
  };
}

/**
 * Verifies and decodes a JWT token
 */
export async function verifyToken(token: string): Promise<TokenPayload> {
  const secret = getJwtSecret();
  
  try {
    const { payload } = await jwtVerify(token, secret, {
      issuer: config.jwt.issuer,
      audience: config.jwt.audience,
      algorithms: [config.jwt.algorithm],
    });
    
    return payload as TokenPayload;
  } catch (error: any) {
    if (error.code === 'ERR_JWT_EXPIRED') {
      throw new AuthError('Token has expired', 'TOKEN_EXPIRED');
    }
    if (error.code === 'ERR_JWT_CLAIM_VALIDATION_FAILED') {
      throw new AuthError('Token validation failed', 'TOKEN_INVALID');
    }
    throw new AuthError('Invalid token', 'TOKEN_INVALID');
  }
}

// =============================================================================
// AUTH ERROR CLASS
// =============================================================================

export class AuthError extends Error {
  code: string;
  statusCode: number;
  
  constructor(message: string, code: string, statusCode: number = 401) {
    super(message);
    this.name = 'AuthError';
    this.code = code;
    this.statusCode = statusCode;
  }
}

// =============================================================================
// SESSION MANAGEMENT
// =============================================================================

/**
 * Generates a secure session ID
 */
export function generateSessionId(): string {
  return randomBytes(32).toString('base64url');
}

/**
 * Session configuration for express-session
 */
export const sessionConfig = {
  name: 'sid', // Don't use default 'connect.sid'
  secret: process.env.SESSION_SECRET || 'change-this-secret',
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: process.env.NODE_ENV === 'production',
    httpOnly: true,
    sameSite: 'strict' as const,
    maxAge: 24 * 60 * 60 * 1000, // 24 hours
  },
  genid: generateSessionId,
};

// =============================================================================
// SECURE RANDOM TOKENS
// =============================================================================

/**
 * Generates a secure random token for password resets, email verification, etc.
 */
export function generateSecureToken(bytes: number = 32): string {
  return randomBytes(bytes).toString('base64url');
}

/**
 * Generates a CSRF token
 */
export function generateCsrfToken(): string {
  return randomBytes(32).toString('base64url');
}

// =============================================================================
// MFA UTILITIES
// =============================================================================

import { authenticator } from 'otplib';

/**
 * Generates a TOTP secret for MFA
 */
export function generateTotpSecret(): string {
  return authenticator.generateSecret();
}

/**
 * Generates a TOTP QR code URL
 */
export function generateTotpUri(
  secret: string,
  email: string,
  issuer: string = 'YourApp'
): string {
  return authenticator.keyuri(email, issuer, secret);
}

/**
 * Verifies a TOTP code
 */
export function verifyTotpCode(code: string, secret: string): boolean {
  return authenticator.verify({ token: code, secret });
}

/**
 * Generates recovery codes
 */
export function generateRecoveryCodes(count: number = 10): string[] {
  return Array.from({ length: count }, () =>
    randomBytes(5).toString('hex').toUpperCase().match(/.{1,5}/g)!.join('-')
  );
}

// =============================================================================
// EXPORTS
// =============================================================================

export {
  HashedPassword,
  TokenPayload,
  TokenPair,
  config as authConfig,
};
